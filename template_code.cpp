///bismillahir  rahmanir  rahim
///la ilaha illallahu muhammadur rasulullah(s)
///sub hanallahi owa bihamdihi ,,subhanallahil azim///
///subhanallah ,  alhamdulillah ,  allahu  akbar
#include<bits/stdc++.h>
using namespace std;
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>
//using namespace __gnu_pbds;
//#define  ordered_set  tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
//#define  ordered_multiset  tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>
//(X).order_of_key(value) /// return lower_bound(value)
//(*X).find_by_order(index) /// return value (0 index)
#define   ll   long long int
#define  ull	 unsigned long long
#define   vi			vector<int>
#define   vll			vector<ll>
#define   pb(x)		 push_back(x)
#define   out(x)		cout<<x<<endl;
#define	pii		 pair<int,int>
#define   mp(x,y)	   make_pair(x,y)
#define   MOD			1000000007
#define   F			 first
#define   S			 second
#define   gcd(a,b)	  __gcd(a,b)
#define   lcm(a,b)		(a*b)/gcd(a,b)
#define   mem(a,b)	  memset(a,b,sizeof(a))
#define   fr(i,a,b)		for(ll i=a;i<=b;i++)
#define   srt(a)		sort (a.begin(),a.end())
#define   rsrt(v)	 sort(v.rbegin(),v.rend());
#define   gsrt(a)	   sort(a.begin(), a.end(), greater<ll>())
#define   rvs(a)	   reverse(a.begin(),a.end())
#define   ctv(v)		for(auto it:v)cout<<it<<' '; cout<<endl;
#define   cnv(v)		for(auto &it:v) cin>>it;
#define   all(v)		v.begin(),v.end()
#define  rall(v)	   v.rbegin(),v.rend()
#define   v_sum(a)	  accumulate(a.begin(),a.end(),0)
#define   v_min(a)	  *min_element (a.begin(),a.end())
#define   v_max(a)	  *max_element (a.begin(),a.end())
#define   upbd(v,x)		   upper_bound(v.begin(),v.end(),r)
#define   lwbd(v,x)		   lower_bound(v.begin(),v.end(),r)
#define   sp			   cout<<fixed<<setprecision(10)<<num<<endl
#define   test	ll t;cin>>t;while(t--)
#define   gap		 " "
//vector<ll>Prime;
//bool mark[10000003];
//void sieve(ll n){ll i,j;mark[1]=1;for(i=4; i<=n; i+=2)mark[i]=1;Prime.push_back(2);for(i=3; i<=n; i+=2){if(!mark[i]){Prime.push_back(i);if(i*i<=n){for(j=i*i; j<=n; j+=(i*2))mark[j]=1;}}}}
//map<ll,ll>Factor;
//void Primefactorize(ll n){for(ll i=0; i<Prime.size() && Prime[i]*Prime[i]<=n; i++){if(n%Prime[i] == 0){while(n%Prime[i] == 0){Factor[Prime[i]]++;n/=Prime[i];}}}if(n>1){Factor[n]++;}}
//(to print without sieve)--// void primeFactors(ll n){while (n % 2 == 0){cout << 2 << " ";n = n/2;}for (ll i = 3; i <= sqrt(n); i = i + 2){while (n % i == 0){cout << i << " ";n = n/i;}}if (n > 2)cout << n << " ";}
//bool sortbysec(const pair<ll,ll>&a ,const pair<ll,ll>&b) {return a.second<b.second;} //sort(v.begin(),v.end(),sortbysec);

///------------graph move-----///////
//const  int  fx[]={+1,-1,+0,+0};
//const  int  fy[]={+0,+0,+1,-1};
//const  int  fx[]={+0,+0,+1,-1,-1,+1,-1,+1};//kings move
//const  int  fy[]={-1,+1,+0,+0,+1,+1,-1,-1};//kings move
//const  int  fx[]={-2,-2,-1,-1,+1,+1,+2,+2};//knight's move
//const  int  fx[]={-1,+1,-2,+2,-2,+2,-1,+1};//knight's move
///-------------------------------------------------
const  int  N=1e5;
const ll mod=1000000007;
#define INF  1e18;
#define  yes   cout<<"Yes"<<endl
#define  no   cout<<"No"<<endl
#define  humayun  ios_base::sync_with_stdio(false); cin.tie(NULL);
//ll  cs=1;cout<<"Case "<<cs++<<": ";
void  solve()
{
	ll a,b,c,x=0,y=0,z,i,j,k,sum=0,sum1=0,ct=0,tp=0,mx=INT_MIN,mn=INT_MAX;


}
//		     ()		       ()
int main()
{
	humayun
	test
	solve();
	return 0;
}


